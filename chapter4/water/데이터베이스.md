# 4. 데이터베이스(DB, DataBase)
- 일정한 규칙, 규약을 통해 구조화되어 저장되어 있는 데이터의 모음
- DBMS(DataBase Management System): 데이터베이스를 제어, 관리하는 통합 시스템
  - DBMS마다 정의된 특정 쿼리 언어를 통해 데이터베이스 내부의 데이터들을 삽입, 삭제, 수정, 조회할 수 있다.
  - 실시간 접근, 동시 공유 가능
- 구조
  |응용 프로그램|
  |---|
  |DBMS|
  |데이터베이스|

<br>

# 4.1 데이터베이스의 기본
# 4.1.1 엔터티(entity)
- 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
- ex) 회원 엔티티는 이름, 아이디, 주소, 전화번호 등의 속성을 가진다.
- 속성은 서비스의 요구 사항에 맞춰 정해진다.

## 약한 엔터티와 강한 엔터티
- 약한 엔터티: 강한 엔터티가 있어야만 존재할 수 있는 종속적인 엔터티
- ex) 건물은 강한 엔터티, 방은 약한 엔터티

<br>

# 4.1.2 릴레이션(relation)
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티 하나에 관한 데이터 => 릴레이션 하나에 담김
- 명칭
  - 관계형 데이터베이스에서는 '테이블'
  - NoSQL에서는 '컬렉션'

## 테이블과 컬렉션
- 데이터베이스의 종류와 구조
  - 관계형 데이터베이스: 레코드-테이블-데이터베이스
  - NoSQL: 도큐먼트-컬렉션-데이터베이스

<br>

# 4.1.3 속성(attribute)
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
- 엔터티의 특징 중 서비스에서 요구되는 것들만 엔티티의 속성이 된다.

<br>

# 4.1.4 도메인(domain)
- 각각의 속성이 가질 수 있는 값의 집합
- ex) 성별이 속성이라면, 도메인은 {남, 여} 집합이다.

<br>

# 4.1.5 필드와 레코드
- 테이블
  - 속성 = 필드
  - 테이블의 행(row) = 레코드 = 튜플
- 속성에 맞는 타입을 정의해야 한다.
- 속성의 이름은 영어 이름으로 쓴다.

## 필드 타입
- DBMS 마다 다르다. 여기서는 MySQL을 기준으로 함

### 숫자 타입
- TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있다.
  - 오른쪽으로 갈수록 최솟값~최댓값 범위가 넓음

### 날짜 타입
#### DATE
- 날짜만 있고 시간은 없다.
- 지원범위: 1000-01-01 ~ 9999-12-31
#### DATETIME
- 날짜, 시간 모두 포함
- 지원범위: 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
- 8바이트 용량
#### TIMESTAMP
- 날짜, 시간 모두 포함
- 지원범위: 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07
- 4바이트 용량

### 문자 타입
#### CHAR, VARCHAR
- CHAR(5) 처럼 최대 몇 자까지 입력 가능한지 설정해야 한다.
- CHAR
  - 테이블 생성시 선언한 길이로 고정된다.
    - 검색에 유리
  - 길이: 0 ~ 255 사이의 값
  - VARCHAR
    - 가변 길이 문자열. 입력한 데이터에 따라 용량을 가변시켜 저장한다.
      - 검색을 별로 하지 않고, 유동적인 길이의 데이터에 적당
    - 길이: 0 ~ 65535 사이의 값
    - VARCHAR(10000)으로 선언해도, 10글자의 레코드를 저장할 때 `10글자 바이트 + 길이기록용 1바이트`로 저장됨
#### TEXT, BLOB
- 큰 데이터를 저장할 때 씀
- TEXT
  - 큰 문자열 저장에 사용
  - 주로 게시판의 본문을 저장할 때 사용
- BLOB
  - 이미지, 동영상 등 큰 데이터 저장에 사용
  - 보통은 S3(아마존 이미지 호스팅 서비스)를 사용하여 서버에 파일을 올리고, 파일 경로를 VARCHAR로 저장한다.
#### ENUM과 SET
- 문자열을 열거한 타입
- 장점: 메모리 공간적 이점
- 단점: 애플리케이션의 수정이 있을 때 ENUM이나 SET에서 정의한 목록을 수정해야 한다.
- ENUM
  - ENUM('문자열1', '문자열2') 형태로 쓰임
    - 이중에서 하나만 선택해야한다.
    - 리스트에 없는 값을 삽입하면 빈 문자열이 대신 삽입된다.
    - 최대 65535개의 요소를 넣을 수 있음
  - ENUM을 쓰면 '문자열1' 등이 0, 1로 매핑되어 메모리를 적게 사용할 수 있다.
- SET
  - ENUM과의 차이점
    - 여러 개의 데이터를 선택할 수 있다
    - 비트 단위 연산 가능
    - 최대 64개의 요소를 넣을 수 있음

<br>

# 4.1.6 관계
- 데이터베이스에 있는 여러 개의 테이블은 서로 관계가 정의되어 있다. 이러한 관계는 관계화살표로 나타낸다.

## 1:1 관계
- ex) 유저 당 유저 이메일은 한개일 때
- 1:1 관계에서는 두 개의 테이블로 나눠져 테이블 구조를 더 이해하게 쉽다.

## 1:N 관계
- ex) 한 유저당 여러 개의 상품을 장바구니에 넣을 때. 장바구니가 비어있을 수 있으므로 화살표에 0을 포함시킨다.
- 한 개체가 다른 많은 개체를 포함하는 관계

## N:M 관계
- 학생과 강의의 관계: 학생도 강의를 많이 들을 수 있고, 강의도 여러 명의 학생을 포함할 수 있다.
- `학생_강의`라는 테이블을 끼워넣는다. 테이블 두 개를 직접 연결하지 않고, 1:N, M:1 관계 두 개로 나눠서 설정한다.

<br>

# 4.1.7 키
- 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.
- 테이블 간의 관계를 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정한다.
- 키 간의 관계
  - 슈퍼키 > 후보키 > (기본키, 대체키)
  - 슈퍼키는 유일성을 만족하고, 후보키는 유일성+최소성 만족
    - `유일성`: 중복되는 값이 없다.
    - `최소성`: 최소 필드만 조합해서 키를 형성한 것
  - 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다.

## 기본키(Primary Key, PK)
- 유일성과 최소성을 만족하는 키
- 자연키 또는 인조키 중에 골라 설정함

### 자연키
- 존재하는 속성 중 중복되지 않은 것을 자연스럽게 뽑아 설정된 키
- ex) 유저테이블의 속성 중 주민등록번호를 뽑아 기본키로 설정한다.
- 언젠가는 변한다.

### 인조키
- ex) 유저테이블의 원래 속성에 더해, 인위적으로 유저 아이디를 부여한다. 이 과정으로 고유 식별자가 생긴다.
- 오라클은 sequence, MySQL은 auto increment로 설정한다.
- 자연키와 대조적으로 변하지 않는다. -> 보통 기본키를 인조키로 설정한다.

## 외래키(Foreign Key, FK)
- 다른 테이블의 기본키를 그대로 참조하는 값.
- 개체와의 관계를 식별하는 데 사용
- 외래키는 내용이 중복되어도 괜찮다.

## 후보키(candidate key)
- 기본키가 될 수 있는 후보들
- 유일성과 최소성 만족

## 대체키(alternate key)
- 후보키가 두 개 이상일 때, 어느 하나를 기본키로 지정하고 남은 후보키들

## 슈퍼키(super key)
- 유일성을 갖춘 키

<br>

# 4.2 ERD와 정규화 과정
- ERD(Entity Relationshop Diagram)
  - 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할. 릴레이션 간의 관계들을 정의한 것

# 4.2.1 ERD의 중요성
- 시스템의 요구사항을 기반으로 작성함
- ERD를 기반으로 데이터베이스를 구축함
- 구축 후에 디버깅 or 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할
- 관계형 구조로 표현할 수 있는 데이터 구성에 유용
- 단점: 비정형 데이터를 충분히 표현할 수 없음
  - `비정형 데이터`: 비구조화 데이터. 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

<br>

# 4.2.2 예제로 배우는 ERD

<br>

# 4.2.3 정규화 과정
- 정규형 원칙을 기반으로 정규형을 만들어가는 과정
  - 정규형(NF, Normal Form): 정규화된 정도
- 데이터베이스 이상 현상이 일어났을 때, 저장 공간을 효율적으로 사용하고 싶을 때 수행
- 정규형 과정으로 테이블을 나누면 성능이 좋아질수도, 나빠질 수도 있다.
  - 쿼리에서 조인을 해야한다면 느려질 수도
  - 서비스에 따라 정규화, 비정규화를 진행해야 함

## 정규형 원칙
- 더 좋은 구조
- 자료의 중복성 감소
- 독립적인 관계는 별개의 릴레이션으로 표현
- 각 릴레이션은 독립적인 표현 가능

## 제1정규형
- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값(atomic value)만으로 구성됨
- 릴레이션의 속성 값은 두 개 이상의 값을 가질 수 없음.

## 제2정규형
- 제1정규형이면서 부분 함수의 종속성을 제거한 형태
- 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적이다
- 릴레이션을 분해할 때
  - 동등한 릴레이션으로 분해
  - 무손실 분해로 해야함

## 제3정규형
- 제2정규형이면서, 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태

### 이행적 함수 종속
- A->B와 B->C가 존재하면 논리적으로 A->C가 성립하는데, 이때 집합 C가 집합 A에 이행적으로 함수 종속 되었다고 한다.
- ex) 유저ID(A), 등급(B), 할인율(C) 가 한 릴레이션에 있었다면, AB, BC 릴레이션 2개로 분리한다.

## 보이스/코드 정규형(BCNF, 제3정규형)
- 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태. 아닌 함수 종속 관계를 모두 제거함
  - `결정자`
    - 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소
    - X->Y일 때 X는 결정자, Y는 종속자

<br>

# 4.3 트랜잭션과 무결성

# 4.3.1 트랜잭션
- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리들(update, insert 등)을 하나로 묶는 단위
- 특징은 원자성, 일관성, 독립성, 지속성이 있다. (ACID 특징)

## 원자성(atomicity)
> all or nothing
- 트랜잭션과 관련된 일이 모두 수행됐거나, 모두 수행되지 않았거나를 보장
- 트랜잭션 커밋 후 다시 롤백했을 때, 처음 상태로 되돌아가야 함
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API 호출 과정이 있으면 안된다.
  - 만약 있다면 롤백 시의 해결방법이 있어야 함
  - 트랜잭션 전파를 신경 써서 관리해야 함
- 커밋과 롤백 덕분에 데이터의 무결성이 보장됨
  - 롤백: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

### 트랜잭션 전파
- 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것.
- Spring에서는 `@Transactional` 애너테이션으로 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리함
- 트랜잭션을 수행할 때(커넥션 단위로 수행) 커넥션 객체를 매번 넘겨주지 않아도 된다.

## 일관성(consistency)
- 허용된 방식으로만 데이터를 변경해야 하는 것
- 데이터는 여러 조건, 규칙을 가지고 이를 만족해야만 유효하다
- ex) 0원 잔고에서 500만원을 출금할 수는 없다.

## 격리성(isolation)
- 트랜잭션 수행 시 방해받지 않는다.
- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동해야 함
- 여러 사용자가 같은 데이터에 접근할 수 있어야 한다.
- |격리 수준|
  |---|
  |READ_UNCOMMITTED|
  |READ_COMMITTED (더티 리드)|
  |REPEATABLE_READ (반복 가능하지 않은 조회)|
  |SERIALIZABLE (팬텀리드)|
  - 위로 갈수록 동시성이 강함, 격리성 약함
  - 위쪽은 아래쪽에서 일어나는 현상을 포함함

### 격리 수준에 따라 발생하는 현상
#### 팬텀 리드(phantom read)
- 한 트랜잭션 내에서 같은 쿼리문이 실행되었음에도 불구하고 조회 결과가 다른 경우
- ex) 두 쿼리의 사이 시간에 레코드를 삽입했을 때 결과가 서로 다를 수 있음
#### 반복 가능하지 않은 조회 (non-repeatable read)
- 한 트랜잭션 내에서 같은 행이 두 번 이상 조회됐는데 그 값이 다른 경우를 가리킨다.
- ex) A와 B가 마지막 남은 영화표를 예매하는데 A가 고민하는 중에 B가 표를 구매하여 A는 상반된 정보를 받게 되는 경우
#### 더티 리드 (Dirty read)
- 생성, 갱신, 혹은 삭제 중에 커밋 되지 않은 데이터 조회를 허용함으로써, 트랜잭션이 종료되면 더 이상 존재하지 않거나, 롤백되었거나, 저장 위치가 바뀌었을 수도 있는 데이터를 읽어들이는 현상

### 격리 수준
#### SERIALIZABLE
- 한 트랜잭션을 다른 트랜잭션으로부터 완전히 분리하여 순차적으로 진행
- 가장 높은 고립성을 띄지만 동시성과 성능은 그만큼 낮아진다.
- 작업 중인 트랜잭션이 완전히 종료될 때까지 다른 어떤 작업도 허용하지 않아 더티 리드, 반복 가능하지 않은 조회, 팬텀 리드를 완벽히 방지한다.
  - 교착 상태가 일어날 확률이 높다.
#### REPEATABLE_READ
- 한 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없게 함
- 새로운 행 추가는 가능함
#### READ_COMMITTED
- MySQL8.0, PostgreSQL, SQL Server, 오라클의 기본 격리 수준이다.
- 커밋 완료된 데이터에 대해서만 조회한다.
- 한 트랜잭션이 접근(수정 등)한 행을 다른 트랜잭션이 수정할 수 있다.
#### READ_UNCOMMITTED
- 한 트랜잭션이 커밋되기 전 다른 트랜잭션에 노출된다.
- 데이터 무결성을 위해서는 사용하지 않는 것이 좋음
- 몇몇 행이 제대로 조회되지 않아도 괜찮을 거대한 양의 데이터를 어림잡아 집계하는 데는 좋다.

## 지속성(durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
- -> 데이터베이스에 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
  - 이를 위해 데이터베이스가 체크섬, 저널링, 롤백 등의 기능 제공
    - `체크섬`: 중복 검사의 한 형태. 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
    - `저널링`
      - 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것.
      - 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

<br>

# 4.3.2 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 종류
  |이름|설명|
  |---|---|
  |개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않는다|
  |참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다|
  |고유 무결성|특성 속성이 고유한 값을 가지도록 조건이 주어진 경우, 그 속성 값은 모두 고유한 값을 가진다|
  |NULL 무결성|특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우, 그 속성 값은 NULL이 될 수 없다|

<br>

# 4.4 데이터베이스의 종류

# 4.4.1 관게형 데이터베이스(RDBMS)
- 행과 열을 가지는 표 형식 데이터를 저장하는  형태의 데이터베이스
- SQL 언어로 조작한다
  - 표준 SQL은 지키지만, 각 제품에 특화되어 있다.
    - 오라클: PL/SQL 사용
    - SQL Server: T-SQL
    - MySQL: SQL
- MySQL, PostgreSQL, SQL Server, MSSQL 등

## MySQL
- 대부분의 운영체제와 호환됨
- 2021년 가장 많이 사용되는 데이터베이스
- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있음
- 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점
- 쿼리 캐시 지원
  - 입력된 쿼리문에 대한 전체 결과 집합 저장
  - 사용자가 작성한 쿼리가 캐시 내의 쿼리와 동일하면 서버는 구문분석, 최적화, 실행 과정을 건너뛸 수 있다.

## PostgreSQL
- MySQL 다음으로 선호되는 데이터베이스
- 특징
  - VACUUM: 디스크 조각이 차지하는 영역을 회수하는 장치
  - 최대 테이블 크기는 32TB
  - SQL 뿐만 아니라 JSON으로 데이터에 접근 가능
  - 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 가능

<br>



## 내용 출처
- https://hleee.medium.com/%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-3287d4bcc64d