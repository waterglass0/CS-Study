# 5. 자료 구조(data structure)
- 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

# 5.1 복잡도
# 5.1.1 시간 복잡도
## 빅오 표기법
- 시간 복잡도
  - 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
  - 보통 빅오 표기법으로 나타냄
    - 입력 크기 n을 기준으로 하여 로직이 몇 번 반복되는지 나타낸 것
    - 필요 시간이 `10n^2 + n`이면, 시간 복잡도는 O(n^2)
    - 가장 영향이 큰 항의 상수 인자만 빼고 나머지는 무시한다.
  
## 시간 복잡도의 존재 이유
- 걸리는 시간이 짧은 효율적인 코드로 개선하기 위해

## 시간 복잡도의 속도 비교
- O(1) > O(logn) > O(n) > O(n^2)
- n이 커질수록 속도 차이가 커진다.

<br>

# 5.1.2 공간 복잡도
- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 정적 변수로 선언된 것, 재귀함수로 인해 동적으로 공간을 계속해서 필요로 할 경우 둘다 포함

<br>

# 5.1.3 자료 구조에서의 시간 복잡도
- 자료 구조를 쓸 때는 시간 복잡도를 고려해야 한다.
- 보통 평균, 최악의 시간복잡도를 참고한다.
![data-structure-operations](./images/data-structure-operations.png)

<br>

# 5.2 선형 자료 구조
- 요소가 일렬로 나열된 자료 구조

# 5.2.1 연결 리스트
- 데이터를 감싼 노드를 포인터로 연결해서 공간적 효율성을 극대화시킨 자료구조
- 시간 복잡도
  - 삽입, 삭제: O(1) 걸림
  - 탐색: O(n) 걸림
- prev 포인터, next 포인터로 앞 뒤 노드를 연결시킴
- 종류
  - 싱글 연결 리스트: next 포인터만 가짐
  - 이중 연결 리스트: next 포인터와 prev 포인터 가짐
    - 함수 종류
      - push_front(): 요소를 앞에서부터 넣음
      - push_back(): 요소를 뒤에서부터 넣음
      - insert(): 요소를 중간에 넣음
  - 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리킴
    - 헤드(head): 맨 앞 노드

<br>

# 5.2.2 배열(array)
- *여기서는 '정적 배열' 기반으로 설명*
- 같은 타입의 변수들로 이루어짐
- 크기가 정해져 있음
- 인접한 메모리 위치에 있는 데이터들의 집합
- 중복 허용
- 순서 있음
- 시간 복잡도
  - 접근: O(1)이어서 랜덤 접근(random access) 가능
  - 삽입, 삭제: O(n) 걸림
    - 데이터 삽입, 삭제를 많이 한다면 연결리스트 사용 권장
    - 배열은 해당 인덱스의 원소에 빠르게 접근해야 하거나, 간단하게 데이터를 쌓고 싶을 때 사용

## 랜덤 접근과 순차적 접근
- 랜덤 접근(직접 접근)
  - 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차적 접근
  - 데이터를 저장된 순서대로 검색

## 배열과 연결 리스트 비교
- 배열
  - 상자를 순서대로 나열한 데이터 구조
  - 탐색이 빠름
    - 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있다
  - 데이터 추가 및 삭제가 느림
    - 모든 상자를 앞으로 옮겨야 추가 가능
- 연결 리스트
  - 상자를 선으로 연결한 형태의 데이터 구조
  - 탐색이 느림
    - 상자 안의 요소를 알려면 주어진 선을 기반으로 상자를 순차적으로 열어봐야 한다.
  - 데이터 추가 및 삭제가 빠름
    - 선을 바꿔서 연결해주기만 하면 추가 가능

<br>

# 5.2.3 벡터(vector)
- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 개수를 모른다면 벡터를 사용해야 함
- 중복 허용
- 순서 있음
- 랜덤 접근 가능
- 시간 복잡도
  - 탐색, 맨 뒤의 요소를 삭제 또는 삽입: O(1)
    - 뒤에서부터 요소를 삽입할 때 벡터의 크기가 증가할 수 있다.
      - 꽉 찬 벡터에 삽입하려고 할 경우에만 크기를 두 배로 늘려 2^n의 크기를 유지한다.
      - 벡터 크기를 늘리는 과정의 시간복잡도: O(1) 
  - 맨 뒤나 맨 앞이 아닌 요소를 삭제 또는 삽입: O(n)
- 함수
  - push_back(): 뒤부터 요소를 더함
  - pop_back(): 뒤부터 요소를 지움
  - erase(): 지움
  - find(): 요소 찾기
  - clear(): 배열 초기화

<br>

# 5.2.4 스택
- 마지막으로 들어간 데이터가 가장 먼저 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조
- 재귀함수, 알고리즘, 웹 브라우저 방문 기록 등에 쓰임
- 시간 복잡도
  - 삽입 및 삭제: O(1)
  - 탐색: O(n)

<br>

# 5.2.5 큐(queue)
- 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 가진 자료 구조
- 쓰임
  - CPU 작업을 기다리는 프로세스와 스레드 행렬
  - 네트워크 접속을 기다리는 행렬
  - 너비 우선 탐색(bfs)
  - 캐시
- 시간 복잡도
  - 삽입 및 삭제: O(1)
  - 탐색: O(n)

<br>

# 5.3 비선형 자료 구조
- 일렬로 나열되지 않은 자료 순서나 관계가 복잡한 구조
- 트리나 그래프

# 5.3.1 그래프
- 정점과 간선으로 이루어진 자료 구조

## 정점과 간선
- 정점(vertex): 간선으로 연결될 수 있는 점
  - 약자로 V 또는 U
  - 'U에서부터 V로 간다'
- 간선(edge): 정점을 연결하는 길
  - 단방향, 양방향 간선이 있다
  - 어떤 정점의 outdegree: 다른 정점으로 나가는 간선
  - 어떤 정점의 indegree: 들어오는 간선
- 그래프(graph): 정점과 간선으로 이루어진 집합

### 가중치
- 간선과 정점 사이에 드는 비용

<br>

# 5.3.2 트리
- 그래프 중 하나로 정점과 간선으로 이루어져 있고, 트리 구조로 배열된 계층적 데이터의 집합
- 루프 노드, 내부 노드, 리프 노드로 구성
- 숲: 트리로 이루어진 집합

## 트리의 특징
1. 부모, 자식 계층 구조
  - 같은 경로 상에서 어떤 노드보다 위에 있으면 부모 노드, 아래에 있으면 자식 노드
2. 간선 수 = 노드 수 - 1 (V-1=E)
3. 임의의 두 노드 사이의 경로는 반드시 존재한다.

## 트리의 구성
### 루트 노드
- 가장 위에 있는 노드
### 내부 노드
- 루트 노드와 리프 노드 사이에 있는 노드들
### 리프 노드
- 자식 노드가 없는 맨 끝 노드
### 트리의 높이와 레벨
- 깊이: 각 노드마다 값이 다르다. 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리
- 높이: 루트 노드부터 가장 먼 리프 노드 까지의 거리
- 레벨: 특정 노드의 깊이에 따른 레벨. 루트 노드를 0 또는 1로 놓고 거리가 증가할 수록 레벨도 1 증가한다.
- 서브트리: 트리 내의 부분 집합

## 이진 트리
- 자식 노드 수가 두 개 이하인 트리
- 분류
  - 정이진 트리(full binary tree): 자식 노드가 0 또는 2개인 이진 트리
  - 완전 이진 트리(complete binary tree): 마지막 레벨을 제외한 위쪽 레벨들은 모두 노드로 채워져있다. 마지막 레벨은 왼쪽부터 채워져있다.
  - 변질 이진 트리(degenerate binary tree): 자식 노드가 하나인 이진 트리
  - 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리
  - 균형 이진 트리(balanced binary tree): 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1 이하인 이진 트리. 레드 블랙 트리가 해당됨

## 이진 탐색 트리(BST)
- 노드의 오른쪽 하위 트리에는 노드 값보다 큰 값이, 왼쪽 하위 트리에는 노드 값보다 작은 값이 들어 있는 트리
- 검색 하기에 용이함
  - 평균 O(logn), 최악 O(n)
    - 삽입 순서에 따라 선형적인 구조가 될 경우 최악의 시간 복잡도가 됨

## AVL 트리(Adelson-Velsky and Landis tree)
- 선형적 트리가 되는 최악의 경우를 방지하고 스스로 균형을 잡는 이진 탐색 트리
- 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1 이하
- 탐색, 삽입, 삭제: O(logn)
- 삭제할 때마다 균형을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시킨다

## 레드 블랙 트리
- 균형 이진 탐색 트리
- 각 노드는 빨간색 or 검은색을 나타내는 추가 비트를 저장
  - 이는 삽입 및 삭제 중에 트리의 균형을 유지하는 데 사용됨
  - 규칙
    - 모든 리프노드, 루트노드는 블랙
    - 어떤 노드가 레드이면 자식은 반드시 블랙
- 탐색, 삽입, 삭제: O(logn)
- C++ STL의 set, multiset, map, multimap이 레드 블랙 트리를 이용하여 구현됨

<br>

# 5.3.3 힙
- 완전 이진 트리 기반의 자료 구조
- 최대힙: 루트 노드에 있는 키가 전체 중 가장 크다. 이는 자식 노드에까지 재귀적으로 이루어져야 한다.
- 최대힙: 루트 노드에 있는 키가 전체 중 가장 작다. 이는 자식 노드에까지 재귀적으로 이루어져야 한다.
- 어떠한 값이 중간에 들어와도 이러한 규칙을 지키게 되어있다.

## 최대 힙의 삽입
1. 추가할 노드를 힙의 마지막 노드에 삽입한다.
2. 부모 노드들과의 크기를 비교하며 교환한다.
3. 최대힙 조건을 만족할 때까지 반복한다.

## 최대힙의 삭제
- 루트 노드가 삭제되면 마지막 노드와 루트 노드를 교환해가며 힙이 재구성 된다.

<br>

# 5.3.4 우선순위 큐
- = 우선순위 대기열
- 대기열에서 우선순위가 높은 요소가 먼저 출력되는 자료 구조
- 힙을 기반으로 구현됨

<br>

# 5.3.5 맵(map)
- 특정 순서에 따라 키와 매핑된 값의 조합으로 된 자료 구조
- 레드 블랙 트리 자료 구조를 기반으로 형성됨
- 삽입하면 자동으로 정렬됨
- 해시 테이블 구현할 때 사용
- 함수
  - clear(): 맵에 있는 모든 요수 삭제
  - size(): map 크기 구하기
  - erase(): 키-매핑된값 지우기
- 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두가지 존재

<br>

# 5.3.6 셋(set)
- 중복되는 요소가 없는 unique한 값만 저장하는 자료 구조

<br>

