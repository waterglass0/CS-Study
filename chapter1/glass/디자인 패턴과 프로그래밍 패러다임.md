# 1.1 디자인 패턴 
>디자인패턴 : 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

## 1.1.1 싱글톤 패턴
>싱글톤 패턴(singleton pattern) : 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴   
* 보통 데이터베이스 연결 모듈에 많이 사용


* ### 장점 
  + 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어든다.   
  + 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅, 마이그레이션이 쉽다.   
  + 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣기 때문에 의존성 방향이 일관된다.   
  + 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 명확해진다.


* ### 단점 
  + 의존성이 높아진다.   
  + 모듈들이 더 분리돼서 클래스 수가 늘어나 복잡성 증가, 런타임 페널티 발생   
* 자바스크립트의 싱글톤 패턴 : 리터럴 {} 또는 new Object로 객체를 생성하게 되면 다른 어떤 객체와도 같지 않기 때문에 이 자체만으로 싱글톤 패턴을 구현할 수 있다.


* 의존성 주입 원칙
  + 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
  + 상위, 하위 모듈 둘 다 추상화에 의존해야 하며, 이 때 추상화는 세부 사항에 의존하지 않는다.

```
// 자바스트립트의 싱글톤
const obj = {
    a : 27
}
const obj2 = {
    a : 27
}
console.log(obj === obj2)
// false
```

* mongoose의 싱글톤 패턴
  - Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose 모듈에서 볼 수 있다.
  - connect()라는 함수는 싱글톤 인스턴스를 반환  
* Node.js에서 MySQL 데이터베이스를 연결할 때도 싱글톤 패턴이 쓰인다.
  - 메인 모듈에서 DB 연결에 관한 인스턴스를 정의하고 다른 모듈에서 해당 인스턴스를 기반으로 쿼리를 보내는 형식

+ **싱글톤 패턴의 단점**
  - TDD(Test Driven Development)를 할 때 걸림돌
    > TDD : 테스트가 독립적이고 어느 순서로든 테스트를 실행할 수 있어야 하는 단위 테스트 위주 개발법   
    > -> 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴   
    > -> 각 테스트마다 **'독립적인'** 인스턴스를 만들기가 어렵다.   

  - 모듈 간의 결합을 강하게 만들 수 있다. :point_right: 의존성 주입으로 해결
  
### 의존성 주입 (DI, Dependency Injection)
> 메인 모듈이 **'직접'** 다른 하위 모듈에 대한 의존성을 주기보다 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 **'간접'**적으로 의존성을 주입하는 방식
>> 의존성이란 종속성이라고도 하며 A가 B에 의존성이 있다면 B의 변경 사항에 대해 A 또한 변해야 한다.

## 1.1.2 팩토리 패턴
> 팩토리 패턴(factory pattern) : 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
* ### 장점
  + 상위, 하위 클래스가 분리되기 때문에 **느슨한 결합**을 가지며, 상위 클래스에서는 인스턴스 생성방식에 대해 전혀 알 필요가 없기 때문에 더 **유연성**을 갖는다.
  + 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있어 **유지 보수성**이 증가된다.

### 1.1.3 전략 패턴
> 전략 패턴(strategy pattern) : 정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하기 않고 전략이라고 부르는 **'캡슐화한 알고리즘'**을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
>> 컨텍스트 : 개발자가 어떠한 작업을 완료하는 데 필요한 모든 정보

* 예: Node.js의 라이브러리 passport의 전략 패턴

### 1.1.4 옵저버 패턴
> 옵저버 패턴(observer pattern) : 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
>> 주체 : 객체의 상태 변화를 보고 있는 관찰자   
>> 옵저버 : 한 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 **'추가 변화 사항'** 이 생기는 객체들   
* 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 한다.
* 주로 이벤트 기반 시스템에 이용
* MVC(Model-View-Controller) 패턴에 사용 :point_right: 주체(모델)에 변경 사항이 생겨 update() 메서드로 옵저버(뷰)에 알려주고 이를 기반으로 컨트롤러 등이 작동
* 예 : 트위터      

* 자바스크립트에서의 옵저버 패턴 : 프록시 객체 이용
  > 프록시 객체 : 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체
  >> 프록시 객체의 매개변수
  >> * target : 프록시할 대상
  >> * handler : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

### 1.1.5 프록시 패턴과 프록시 서버
> 프록시 패턴(proxy pattern) : 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
* 객체의 속성, 변환 등을 보완   
* 데이터 검증, 캐싱, 로깅에 사용   
* 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용   

> 프록시 서버(proxy server) : 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 흐로그램
* nginx : 비동기 벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버, 주로 Node.js 서버 앞단의 프록시 서버로 활용
  > :point_right: 익명 사용자의 직접적인 서버로의 접근을 차단하고 간접적으로 한 단계를 더 거침으로써 보안성 강화
  > nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있고, 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수도 있다.

* 프록시 서버로 쓰는 CloudFlare
  + 전 세계적으로 분산된 서버가 있어 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스
  * 이점
    * DDOS 공격 방어
      > DDOS : 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형
      + CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단
      + 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막을 수 있고, 공격에 대한 방화벽 대시보드도 제공
    * HTTPS 구축
      + 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축하는 대신 CloudFlare를 사용해 인증서 없이 HTTPS 구축

* CORS와 프런트엔드의 프록시 서버
  > CORS(Cross-Origin Resource Sharing) : 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP헤더 기반 메커니즘
  >> 프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도 한다.   
  >> ex)   
  >> - 프론트엔드 테스팅 : 127.0.0.1:3000   
  >> - 백엔드 서버 : 127.0.0.1:12010 :point_right: 포트 번호가 달라 CORS 에러   
  >> - :point_right: 프록시 서버를 둬서 프론트엔드 서버에서 요청되는 오리진을 127.0.0.1:12010으로 바꾼다.   
  >>> origin : 프로토콜과 호스트 이름, 포트의 조합
  >>> - ex) https://test.com:12010/test 의 오리진은 https:test.com:12010
  

### 1.1.6 이터레이터 패턴
> 이터레이터 패턴(iterator pattern) : 이터레이터를 이용하여 컬렉션의 요소들에 접근하는 디자인 패턴
* 순회할 수 있는 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

### 1.1.7 노출모듈 패턴
> 노출모듈 패턴(revealing module pattern) : 즉시 실행 함수를 통해 private, public과 같은 접근 제어자를 만드는 패턴
* 자바스크립트는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트 실행
  + 노출모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 함
  + 노출모듈 패턴 기반으로 만든 JS 모듈 방식 : CJS(CommonJS)

### 1.1.8 MVC 패턴
> MVC 패턴 : 모델, 뷰, 컨트롤러로 이루어진 다자인 패턴
> * 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스의 각각의 구성 요소에만 집중해서 개발할 수 있다.
* 장점 : 재사용성과 확장성 용이
* 단점 : 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다.   
* MVC 패턴의 예 : 리액트

1. 모델
  - 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등
  - 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신

2. 뷰
  - inbox, checkbox, textarea 등 사용자 인터페이스 요소 
  - 모델을 기반으로 사용자가 볼 수 있는 화면
  - 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 화면에 표시하는 정보만 가지고 있어야 한다.
  - 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

3. 컨트롤러
  - 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할
  - 이벤트 등 메인 로직 담당
  - 모델과 뷰의 생명주기도 관리
  - 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 구성 요소에 해당 내용에 대해 알려줌

### 1.1.9 MVP 패턴
> MVP 패턴 : MVC 패턴의 파생. MVC의 Controller 프레젠터(Presenter)로 교체된 패턴
* 뷰와 프레젠터가 1:1 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지님

### 1.1.10 MVVM 패턴
> MVVM 패턴 : MVC의 Controller가 뷰모델(view model)로 바뀐 패턴
* 뷰모델 : 뷰를 더 추상화한 계층
* MVC 패턴과 다르게 커맨드와 데이터 바인딩을 가짐
* 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
* UI를 변도의 코드 수정 없이 재사용 가능
* 단위 테스팅이 쉽다.
* 예 : Vue.js

---
# 1.2 프로그래밍 패러다임
> 프로그래밍 패러다임(programming paradigm) : 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
* 예
  > 객체지향 프로그래밍 : 프로그램 == 상호 작용하는 객체들의 집합   
  > 함수형 프로그래밍: 프로그램 == 상태 값을 지니지 않는 함수 값들의 연속
* 패러다임 지원 언어 : C++, 파이썬, 자바스크립트 등
* 자바는 jdk 1.8 이전은 객체지향 프로그래밍을, jdk 1.8부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입 + 선언형 프로그래밍을 위해 스트림같은 표준 API 도입

|    |  :프로그래밍 패러다임 |
| :---:  |:------: |
| 선언형 | :grey_exclamation: 명령형        |
| 함수형 | :grey_exclamation: 객체지향형, 절차지향형 |

### 1.2.1 선언형과 함수형 프로그래밍
> 선언형 프로그래밍(declarative programming) 
 * '무엇을' 풀어내는가에 집중하는 패러다임
 * "프로그램은 함수로 이루어진 것이다."
 * 함수형 프로그래밍(functional programming)은 선언형 패러다임의 일종

> 함수형 프로그래밍 : '순수 함수'들을 블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 그로그래밍 패러다임
  + 순수 함수 : 출석이 입력에만 의존하는 것
  + 고차 함수 : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것
    - 일급 객체
      + 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 한다.
      + 입급 객체 특징
        - 변수나 메서드에 함수를 할당할수 있다
        - 함수 안에 함수를 매개변수로 담을 수 있다
        - 함수가 함수를 반환할 수 있다.

### 1.2.2 객체지향 프로그래밍
> 객체지향 프로그래밍(OOP, Object Oriented Programming) 
* 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
* 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.
* 특징
  1. 추상화(abstraction) : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
  2. 캡슐화(capsulation) : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
  3. 상속성(inheritance) : 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
     - 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요
  4. 다형성(polymorphism) : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것 
     - ex) 오버로딩, 오버라이딩
  > 오버로딩(overloading) 
    - 같은 이름을 가진 메서드를 메서드의 타입, 매개변수의 유형, 개수 등으로 여러 개 두는 것
    - 컴파일 중에 발생하는 '정적' 다형성   
  >  오버라이딩(overriging) 
    - 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
    - 런타임 중에 발생하는 '동적' 다형성


### 설계 원칙
* SOLLD 원칙
  1. **S** : 단일 책임 원칙(SRP, Single Responsibility Principle)
     - 모든 클래스는 각각 하나의 책임만 가져야 한다.   
     - 예) A라는 로직이 있다면 어떠한 클래스는 A에 관한 클래스여야 하고 이를 수정도 A와 관련된 수정이어야 한다.    
  2. **O** : 개방-폐쇄 원칙(OCP: OPen Closed Principle) 
     - 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고, 수정할 때는 닫혀 있어야 한다.   
     - 즉, 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다.
  3. **L** : 리스코프 치환 법칙(LSP : Liskov Substitution Principle)
     - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.      
     - 클래스의 부모, 자식 계층 관계에서 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만드는 것   
  4. **I** : 인터페이스 분리원칙(ISP, Interface Segregation Principle)
     - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 한다.   
  5. **D** : 의존 역전 원칙(DIP : Dependency Inversion Principle)   
     - 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙   
     - 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다.   

### 1.2.3 절차형 프로그래밍
> 절차형 프로그래밍
* 로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐
* 일이 진행되는 방식으로 코드를 구현하기만 하면 되므로 코드의 가독성이 좋고, 실행 속도가 빠르다.
* 단점 
  - 모듈화가 어렵다   
  - 유지 보수성이 떨어진다.   
* 계산이 많은 작업에 쓰인다. ex) 포트란(fortran)을 이용한 대기 과학 관련 연산 작업, 머신 러닝의 배치 작업

### 1.2.4 패러다임의 혼합
* 비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정해야 한다.   
* 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 좋다.   
* 예) 백엔드에서 머신 러닝 파이프라인은 절차지향형 패러다임, 거래 관련 로직은 함수형 프로그래밍을 적용한다.   










